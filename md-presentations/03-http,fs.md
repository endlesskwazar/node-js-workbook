# Node.js HTTP FS



## HTTP


### HTTP
**HTTP** - це протокол, що дозволяє отримувати різні ресурси, наприклад HTML-документи. Протокол HTTP лежить в основі обміну даними в Інтернеті. HTTP є протоколом клієнт-серверної взаємодії, що означає ініціювання запитів до сервера самим одержувачем, зазвичай веб-браузером. Отриманий підсумковий документ буде реконструйований з різних суб - документів, наприклад, з окремо отриманого тексту, опису структури документа, зображень, відео-файлів, скриптів і багато чого іншого.


### HTTP
Абревіатура HTTP розшифровується як HyperText Transfer Protocol, «протокол передачі гіпертексту». Відповідно до специфікації OSI, HTTP є протоколом прикладного (верхнього, 7-го) рівня. Актуальна на даний момент версія протоколу, HTTP 1.1, описана в специфікації RFC 2616.


### HTTP
Хоча HTTP був розроблений ще на початку 1990-х років, за рахунок своєї розширюваності надалі він весь час удосконалювався. HTTP є протоколом прикладного рівня, який найчастіше використовує можливості іншого протоколу - TCP (або TLS - захищений TCP) - для пересилання своїх повідомлень, проте будь-який інший надійний транспортний протокол теоретично може бути використаний для доставки таких повідомлень. Завдяки своїй розширюваності, він використовується не тільки для отримання клієнтом гіпертекстових документів або зображень і відео, але і для передачі контенту серверів, наприклад, за допомогою HTML-форм.


### HTTP
Для того, щоб сформувати HTTP - запит, необхідно скласти стартовий рядок, а також задати принаймні один заголовок - це заголовок Host, який є обов'язковим, і повинен бути присутнім в кожному запиті. Справа в тому, що перетворення доменного імені в IP-адресу здійснюється на стороні клієнта, і, відповідно, коли ви відкриваєте TCP - з'єднання, то віддалений сервер не володіє жодною інформацією про те, яка саме адреса використовувалася для з'єднання.


### HTTP
Стартова (початкова) рядок запиту для HTTP 1.1 складається за такою схемою:
```
Метод URI HTTP/Версія
```


### HTTP
Наприклад (такий стартовий рядок може вказувати на те, що запитується головна сторінка сайту):
```
GET / HTTP/1.1
```


### HTTP
Метод HTTP (англ. HTTP Method) - послідовність з будь-яких символів, крім керуючих і роздільників, яка вказує на основну операцію над ресурсом. Зазвичай метод являє собою короткий англійське слово, записане великими літерами. Зверніть увагу, що назва методу чутливе до регістру.


### HTTP
Сервер може використовувати будь-які методи, не існує обов'язкових методів для сервера або клієнта. Якщо сервер не розпізнав вказаний клієнтом метод, то він повинен повернути статус 501 (Not Implemented). Якщо серверу метод відомий, але він непридатний до конкретного ресурсу, то повертається повідомлення з кодом 405 (Method Not Allowed).


### HTTP
|Метод|Пояснення|
|-|-|
|GET|Метод GET запитує представлення ресурса. Запити з використанням цього методу можуть тільки отримувати дані.|
|HEAD|HEAD запитує ресурс так само, як і метод GET, але без тіла відповіді.|
|POST|POST використовується для відправки сутностей до певного ресурсу. Часто викликає зміна стану або якісь побічні ефекти на сервері.|
|PUT|PUT замінює всі поточні уявлення ресурсу даними запиту.|
|DELETE|DELETE видаляє вказаний ресурс.
|CONNECT|CONNECT встановлює "тунель" до сервера, визначеному по ресурсу.|
|OPTIONS|OPTIONS використовується для опису параметрів з'єднання з ресурсом.|
|TRACE |TRACE виконує виклик повертається тестового повідомлення з ресурсу.|
|PATCH |PATCH використовується для часткової зміни ресурсу.|


### HTTP
URI (Uniform Resource Identifier, уніфікований ідентифікатор ресурсу) - шлях до конкретного ресурсу (наприклад, документа), над яким необхідно здійснити операцію (наприклад, в разі використання методу GET мається на увазі отримання ресурсу).


### HTTP
Деякі запити можуть не ставитися до будь-якого ресурсу, в цьому випадку замість URI в стартову рядок може бути додана зірочка (Астеріск, символ «*»). Наприклад, це може бути запит, який відноситься до самого веб-сервера, а не якого-небудь конкретного ресурсу. В цьому випадку стартова рядок може виглядати так:

```
OPTIONS * HTTP/1.1
```


### HTTP
Для того, щоб звернутися до веб-сторінки по визначеному адресу (в даному випадку шлях до ресурсу - це «/»), нам слід відправити наступний запит:

```
GET / HTTP/1.1
Host: alizar.habrahabr.ru 
```


### Як розуміти відповідь
Стартовий рядок відповіді має наступну структуру:

```
HTTP / Версія Код стану Пояснення
```


### Як розуміти відповідь
Версія протоколу тут задається так само, як в запиті.


### Як розуміти відповідь
*Код стану (Status Code)** - три цифри (перша з яких вказує на клас стану), які визначають результат здійснення запиту. Наприклад, в разі, якщо був використаний метод GET, і сервер надає ресурс із зазначеним ідентифікатором, то такий стан задається за допомогою коду 200. Якщо сервер повідомляє про те, що такого ресурсу не існує - 404. Якщо сервер повідомляє про те, що не може надати доступ до цього ресурсу через відсутність необхідних привілеїв у клієнта, то використовується код 403. Специфікація HTTP 1.1 визначає 40 різних кодів HTTP, а також допускається розширення протоколу і використання додаткових кодів станів.


### Як розуміти відповідь
Список кодів можна переглянути [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Status)


### Як розуміти відповідь
Пояснення до коду стану (Reason Phrase) - текстове пояснення до коду відповіді, призначене для спрощення читання відповіді людиною. Пояснення може не враховуватися клієнтським програмним забезпеченням, а також може відрізнятися від стандартного в деяких реалізаціях серверного програмного забезпечення.


### Як розуміти відповідь
Після стартового рядка слідують заголовки, а також тіло відповіді. наприклад:

```
HTTP/1.1 200 OK
Server: nginx/1.2.1
Date: Sat, 08 Mar 2014 22:53:46 GMT
Content-Type: application/octet-stream
Content-Length: 7
Last-Modified: Sat, 08 Mar 2014 22:53:30 GMT
Connection: keep-alive Accept-Ranges: bytes
<br>
<br>
Wisdom 
```


### Як розуміти відповідь
Тіло відповіді слідує через два розриву рядків після останнього заголовка. Для визначення закінчення тіла відповіді використовується значення заголовка Content-Length (в даному випадку відповідь містить 7 вісімкових байтів: слово «Wisdom» і символ розриву рядків).



## Node.js Model


### Node.js Model
**Перший основний тезис Node.js** полягає в тому, що операції введення / виводу обходяться дорого:

![](../resources/img/3/4.png)


### Node.js Model
Взагалі, це найбільше марнотратство в сучасному програмуванні - чекати, поки завершиться операція введення / виводу (I / O). Ось деякі підходи, які існують у веб - програмуванні:

- **синхронні операції**: за раз ви обробляєте тільки один запит, обробка запитів відбувається в порядку черги. Плюси: простота. Мінуси: Будь-який запит може заблокувати обробку всіх інших.


### Node.js Model
- **Створення нового процесу:** кожен раз ви запускаєте новий процес для обробки нового запиту. Плюси: простота. Мінуси: fork () - це молоток unix-програмістів. Він простий в застосуванні, а кожна проблема завжди схожа на цвях. Зазвичай такий підхід призводить до поганої масштабованості. Все таки, сотні відкритих підключень - це сотні запущених процесів.
- **Потоки:** Ви обробляєте кожен запит в окремому тред. Плюси: Простота. На відміну від fork (), для запуску тред потрібно менше ресурсів. Мінуси: Ваш комп'ютер може не підтримувати роботу з тред. Крім того, програмування тредов дуже швидко стає головним болем: доводиться постійно турбуватися про проблеми доступу до загальних ресурсів.


### Node.js Model
**Другий основний тез** полягає в тому, що обробка кожного нового підключення в окремому треді призводить до великих витрат пам'яті. Наприклад, Apache, працюючи з тред, споживає набагато більше пам'яті, ніж Nginx.

Node.js використовує один потік для виконання всього вашого коду, тим не менш, все, крім вашого коду, запускається паралельно. Така модель називається "single-threaded non-blocking asynchronous".


### Node.js Model
Асинхроність досягається за допомогою "event loop":

![](../resources/img/3/5.png)



## Build-in Modlues FS, HTTP


### FS
Якщо ви хочете зробити веб-сервер на Node.js або просто якийсь додаток, тоді вам потрібно вміти читати файли. Node надає бібліотеку **fs** для роботи з файловою системою.

Для роботи із модулем його потрібно підключити:

```js
var fs = require('fs');
```


### FS
"Нормальний" спосіб читання/запису файлів в Node.js це асинхронни1 способом. Це означає, що ви викликаєте команду читання або запису файлу і передаєте callback, який буде викликаний при завершенні. Це дозволяє працювати з декількома запитами паралельно.


### FS. readFile
Використовуйте метод fs.readFile () для асинхронного читання фізичного файлу.

```js
fs.readFile(fileName [,options], callback)
```

де:

- fileName: повний шлях та ім'я файлу у вигляді рядка.
- options: може бути об'єктом або рядком, який може включати кодування та прапор. Кодування за замовчуванням utf8, а прапор за замовчуванням - "r".
- callback: функція з двома параметрами err та fd. Буде викликана, коли операція readFile завершиться.


### FS. readFile
```js
var fs = require('fs');

fs.readFile('text.txt', 'utf-8', (err, data) => {
  if(err) {
    console.log(err);
  }
  else {
    console.log(data);
  }
});

fs.readFile('text.txt', (err, data) => {
  if(err) {
    console.log(err);
  }
  else {
    console.log(data);
  }
});
```


### FS.writefile
Використовуйте метод fs.writeFile () для запису даних у файл. Якщо файл вже існує, він перезаписує вміст, інакше він створює новий файл і записує в нього дані.

```js
fs.writeFile(filename, data[, options], callback)
```

де:
- filename: повний шлях та ім'я файлу у вигляді рядка.
- data: вміст, який слід записати у файл.
- options: Параметр параметрів може бути об'єктом або рядком, який може включати кодування, режим та прапор. Кодування за замовчуванням - utf8, а прапор за замовчуванням - "r".
- callback: функція з двома параметрами err та fd. Це буде викликано, коли операція запису завершиться.


### FS.writefile
```js
var fs = require('fs');

const text = `Some text`;

fs.writeFile('text.txt', text, (err) => {
  if(err){
    console.log('Cant write');
  }
});
```


### FS.appendFile
Функція fs,appendFile() аналогічна writeFile(), крім того, що вона не перезаписує вміст фуйлу.


### Основні функції fs
|Функція|Пояснення|
|-|-|
|fs.readFile(fileName [,options], callback)|Читає наявний файл.|
|fs.writeFile(filename, data[, options], callback)|Записується у файл. Якщо файл існує, тоді перезаписує вміст, інакше створюється новий файл.|
|fs.open(path, flags[, mode], callback)|Відкриває файл для читання чи запису.|
|fs.rename(oldPath, newPath, callback)|Перейменовує існуючий файл.|
|fs.chown(path, uid, gid, callback)|Асинхронний chown.|
|fs.stat(path, callback)|Повертає об'єкт fs.stat, який включає важливу статистику файлів.|
|fs.rmdir(path, callback) |Перейменовує існуючий каталог.|
|fs.mkdir(path[, mode], callback) |Створює новий каталог.|
|fs.readdir(path, callback) |Читає вміст вказаного каталогу.|
|fs.exists(path, callback) |Визначає, існує вказаний файл чи ні.|
|fs.access(path[, mode], callback) |Тестує дозволи користувача на вказаний файл.|
|fs.appendFile(file, data[, options], callback) |Додає новий вміст до наявного файлу.|


### Синхронні функції
Крім "нормальних" асинхронних модуль fs містить синхронні функції:

|Асинхронна|Синхронна|
|-|-|
|readFile()|readFileSync()|
|writeFile()|writeFileSync()|
|appendFile()|appendFileSync()|


### Модуль HTTP
Node.js має вбудований модуль під назвою HTTP, який дозволяє Node.js передавати дані через протокол передачі гіпертексту (HTTP).

Підключення модуля:

```js
var http = require('http'); 
```


### Вбудований сервер
Модуль HTTP може створити сервер HTTP, який прослуховує порти сервера і повертає відповідь клієнту.

```js
http.createServer(function(req, res){
	res.write('Hello world');
	res.end();
}).listen(8080);
```


### Вбудований сервер
Функція createServer приймає callback, який може бути і не анонімним:

```js
const handler = (req, res) => {
	res.write('Hello worlds');
	res.end();
};

http.createServer(handler).listen(8080);
```


### Вбудований сервер
Функція write може ввідавати HTML:

```js
res.write('<h1>Hello World</h1>');
```


### Simple routing
Усі URL-адреси для localhost передаються одній функції зворотного виклику. Для написання логіки маршрутизації використовуйте req.url і req.method:

```js
const http = require('http');

http.createServer((req, res) => {

    console.log(`req.url == ${req.url} req.method == ${req.method}`);

    if(req.url == '/about' && req.method == 'GET'){
        res.write('Res from about page, method GET');
        res.end();
    }
    else {
        if (req.url == '/contact' && req.method == 'GET' ) {
            res.write('Res from contact page, method GET');
            res.end();
        }
    }

    res.write('HTTP 404: Not Found');
	  res.end();

}).listen(8000);
```


### Повернення HTML - файлу у відповідь
Для того, щоб повернути html - файл у відповідь достатньо його прочитати і повернути текстовий вміст:

about.html:

```html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;About&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;This is about page&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
```


### Повернення HTML - файлу у відповідь
```js
const http = require('http');
const fs = require('fs');

http.createServer((req, res) => {

    console.log(`req.url == ${req.url} req.method == ${req.method}`);

    if(req.url == '/about' && req.method == 'GET'){
        fs.readFile('about.html', 'utf-8', (err, data) => {
            if (err) {
                console.log(err);
            }

            res.write(data);
            res.end();
        });
        
    }
    else {
        if (req.url == '/contact' && req.method == 'GET' ) {
            res.write('Res from contact page, method GET');
            res.end();
        }
    }

    res.write('HTTP 404: Not Found');
    res.end();
}).listen(8000);
```


### nodemon
Якщо ми запустимо сервер через команду node і внеемо зміни в джерельний код, то ці зміни будуть застосовані лише, коли сервер буде перезавантажений. Це не дуже зручно при розробці, оскільки доводеться зупиняти і замускати сервер кожного разу, коли змінився джерельний код. Для зручності, при розробці можна використовувати nodemon.


### nodemon
Для встановлення nodemon глобально можа:

```
npm install -g nodemon
```

або встановити як dev - залежність:

```
npm install --save-dev nodemon
```


### nodemon
Якщо nodemon був встановлений глобально запустити можна так:
```
nodemon [your node app]
```

Якщо локально, то:

```
node_modules/.bin/nodemon [app]
```


### nodemon
або створити скрипт в package.json

```js
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start-dev": "nodemon index.js"
  },
```

```
npm run start-dev
```


### nodemon
Або і взагалі без встановлення, використовуючи npx:
```
npx nodemon [app]
```


### Читання GET і POST - параметрів
Parse http requests with content-type multipart/form-data, also known as file uploads. 

This is a Node.js module available through the npm registry. Installation is done using the npm install command: 

```
npm install --save multiparty
```

to include multiparty: 

```
var multiparty = require('multiparty');
```


### Читання GET і POST - параметрів
```js
if(req.url === '/files' && req.method === 'POST'){
	let form = new multiparty.Form();
	form.parse(req, (err, fields, files) => {
		if(err){
			res.write('Error parsing form');
			res.end();
			return;
		}
		res.write(`passed filename is ${fields['filename']}`);
		res.end();
	})
	return;
}
```


### Example project
repo: https://github.com/endlesskwazar/node-js-examples

branch: http