# ES6

# Ключові слова let і const

В ES5 є два способи, щоб оголосити змінні:
1. Використовуючи ключове слово var
```js
var count = 1;
```
2. Без використання ключових слів в форматі ідентифікатор = значення(при умові, що [strict mode](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode) не ввімкнений)
```js
count = 1
```

Якщо другий спосіб - зло, так - як змінна оголошена тиким способом має глобальну область видимості, навіть якщо знаходиться всередені функцій, то перший спосіб це єдине, що залишається для оголошення змінних.

Але, ключове слово var також має свої недоліки. Давайте їх розглянемо.

1. Область видимості, при оголошенні в циклах і умовних операторах

Цікавою особливістю оголоішення зміних за допомогою var в циклах і умовних конструкціях є те, що ці змінні залишаються видимі після їх виконання. Наприклад розглянемо наступний код:

```js
for(var i = 0; i<6; i++){
}

console.log(i); //6

if(true){
	var if_variable = 3;
}

console.log(if_variable); //3
```
Змінна i, яка використовувалася для ітерації для цикла for і була оголошена в ньому ж видна за його межами. Також змінна if_variable, яка була оголошена в контексті умовного оператора також видна за його межами.

2. Перевизначення змінної

Якщо змінна вже була оголошена і ми хочемо ще раз оголосити змінну з таким же самим ідентифікатором, javascript дозволить це зробити.

```js
var counter = 1;
var counter = 2;
```

Хоча може здатися, що на цю особливість var можна було б і не звертати увагу, але сама ідея оголошення змінної із вже існуючим ідентифікатором, можливо є помилкою людини, майбутнім багом, який би хотілося дізнатися на місті, а не через процес дебага.

3. Існування до моменту ініціалізації

Насправді змінна, оголошена через var вже існує, але її вміст невизначений. Давайте розглянемо наступний код:

```js
console.log(a); //undefined

var a = 3;
```

Значення зміної undefined, що означає, що її вміст не визначений.

4. Класична задача "Армія функцій"

Наступний код створює масив функцій-стрільців shooters. За задумом, кожен стрілець повинен виводити свій номер:

```js
function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++) {
    var shooter = function() { // shooters function
      console.log( i ); // should output number of shooters
    };
    shooters.push(shooter);
  }

  return shooters;
}

var army = makeArmy();

army[0](); // shooter outputs 10, but need 0
army[5](); // shooter outputs 10...
// .. all shouters outputs
```

Це відбувається, тому що для всіх ітерацій циклів використовується одна змінна.



## Ключове слово let

В ES6 передбачений новий спосіб для оголошення змінних через ключове слово var. **Зверніть увагу**, що ключове слово var також доступне і може бути використане.

Синтаксис оголошення змінних через ключове слово let:
```js
let ідентифікатор = значення;
let counter = 3;
```

У змінної оголошеної через let є чотири ключових відмінностей від var:

1. Область видимості змінної let - блок {}

Якщо ми перепишимо минулий приклад, де була продемонстрована особливість оголошення змінної через var всередині циклів у умовних операторів із використанням ключового слова let, можна побачити, що let має цілком зрозумілу область видимості, а саме не видний за межами циклів і умовних операторів.

```js
for(var i = 0; i<6; i++){
}

console.log(i); //ReferenceError: i is not defined

if(true){
	var if_variable = 3; //3
}

console.log(if_variable); //ReferenceError: if_variable is not defined
```

**Зверніть увагу**, що в цьому випадку трапляється помилка і код зупиняє своє виконання.

2.

3.

4.

## Ключове слово const

Оголошення const задає константу, тобто змінну, яку не можна змінювати:

```js
const LOCALE = 'UA';
LOCALE = "EU"; //TypeError: Assignment to constant variable.
```

В остальном объявление const полностью аналогично let.

> Зауважимо, що якщо в константу присвоєно об'єкт, то від зміни захищена сама константа, але не властивості всередині неї:

```js
const user = {
  name: "Вася"
};

user.name = "Петя"; // Можна
user = 5; // Буде помилка
```

# Функції стрілки(Arrow functions)

**Вирази стрілочних функцій** мають більш короткий синтаксис в порівнянні з функціональними виразами і лексично прив'язані до значення this (але не прив'язані до власного this, arguments, super, або new.target). Стрілочні функції завжди анонімні.

Давайте розглянемо функцію вищого порядку, яка приймає іншу функцію і її викликає:

```js
function outer(innerFunc){
  var message = "Hello World";
  innerFunc(message);
}

outer(function(message){
  console.log(message);
});
```

В якості параметра, при виклику функції outer ми передаємо анонімну функцію. Функція верхнього порядку(outer), приймає функцію і викликає її в собі.

Розглянемо, як можна скоротити написання анонімної функції, при її передачі у функцію зовнішнього порядку.

```js
function outer(innerFunc){
  var message = "Hello World";
  innerFunc(message);
}

outer(message => {
  console.log(message);
});
```

Можна побічити, що ми позбавилися від написання ключового слова function і від дужок, які визначають параметри функції.

Стрілочну функцію можна присвоїти змінній. Наприклад:

```js
var func1 = message => console.log(message);

let func2 = message => console.log(message);

const func3 = message => console.log(message);

func1('Func1'); //Func1
func2('Func2'); //Func2
func3('Func3'); //Func3
```

Зверніть увагу, що після оператора стрілка(=>) в прикладі відсутні фігурні дужки, їх можна опустити, якщо тіло стрілкової функції складається із одного виразу.

За замовчуванням якщо в тілі стрілкової функції немає оператора return, він ставиться автоматично. Наприклад:

```js
const sum = (a, b) => a+b;
let res = sum(1,2);
console.log(res); //3
```

Навідміну, від минулого прикладу, ми обернули параметри, які приймає стрілочна функція в дужки. Насправді до синтаксису написання параметрів в стрілкових функціях є деякі правила, в залежності від кількості параметрів.

Правила написання параметрів стрілкових функцій:

1. Якщо стрілкова функція не має жодного параметра, обо має більше двох, то параметри заточуються в круглі дужки:

```js
let func1 = () => 5;
let func2 = (a,b) => a+b;
let func3 = (a,b,c) => a+b+c;
```

2. Якщо стрілкова функція має один параметр, то круглі дужки можна опустити:

```js
let func1 = a => a++;
let func2 = (a) => a++;
```

# Параметри за замовчуванням

# Template Literals

# Деструктуризація

# Класи

# Символьний тип

# Promises(Проміси)

# Домашнє завдання

## Варіанти

# Контрольні запитання