<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>ES6</title>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap-responsive.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/pilcrow.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/hljs-github.min.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/style.css"/>
  </head>
<body>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3"><ul class="nav nav-list">
    <li class="sidebar-header-1"><a href="#es6">ES6</a></li>
    <li class="sidebar-header-1"><a href="#ключові-слова-let-і-const">Ключові слова let і const</a></li>
    <li class="sidebar-header-2"><a href="#ключове-слово-let">Ключове слово let</a></li>
    <li class="sidebar-header-2"><a href="#ключове-слово-const">Ключове слово const</a></li>
    <li class="sidebar-header-1"><a href="#функції-стрілки(arrow-functions)">Функції стрілки(Arrow functions)</a></li>
    <li class="sidebar-header-1"><a href="#параметри-за-замовчуванням">Параметри за замовчуванням</a></li>
    <li class="sidebar-header-1"><a href="#template-literals">Template Literals</a></li>
    <li class="sidebar-header-1"><a href="#деструктуризація">Деструктуризація</a></li>
    <li class="sidebar-header-1"><a href="#класи">Класи</a></li>
    <li class="sidebar-header-1"><a href="#символьний-тип">Символьний тип</a></li>
    <li class="sidebar-header-1"><a href="#promises(проміси)">Promises(Проміси)</a></li>
    <li class="sidebar-header-1"><a href="#домашнє-завдання">Домашнє завдання</a></li>
    <li class="sidebar-header-2"><a href="#варіанти">Варіанти</a></li>
    <li class="sidebar-header-1"><a href="#контрольні-запитання">Контрольні запитання</a></li>
</ul>
      </div>
      <div class="span9 main"><h1 id="es6"><a class="header-link" href="#es6"></a>ES6</h1>
<h1 id="ключові-слова-let-і-const"><a class="header-link" href="#ключові-слова-let-і-const"></a>Ключові слова let і const</h1>
<p>В ES5 є два способи, щоб оголосити змінні:</p>
<ol class="list">
<li>Використовуючи ключове слово var<pre class="hljs"><code><span class="hljs-keyword">var</span> count = <span class="hljs-number">1</span>;</code></pre></li>
<li>Без використання ключових слів в форматі ідентифікатор = значення(при умові, що <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a> не ввімкнений)<pre class="hljs"><code>count = <span class="hljs-number">1</span></code></pre></li>
</ol>
<p>Якщо другий спосіб - зло, так - як змінна оголошена тиким способом має глобальну область видимості, навіть якщо знаходиться всередені функцій, то перший спосіб це єдине, що залишається для оголошення змінних.</p>
<p>Але, ключове слово var також має свої недоліки. Давайте їх розглянемо.</p>
<ol class="list">
<li>Область видимості, при оголошенні в циклах і умовних операторах</li>
</ol>
<p>Цікавою особливістю оголоішення зміних за допомогою var в циклах і умовних конструкціях є те, що ці змінні залишаються видимі після їх виконання. Наприклад розглянемо наступний код:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++){
}

<span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">//6</span>

<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-keyword">var</span> if_variable = <span class="hljs-number">3</span>;
}

<span class="hljs-built_in">console</span>.log(if_variable); <span class="hljs-comment">//3</span></code></pre><p>Змінна i, яка використовувалася для ітерації для цикла for і була оголошена в ньому ж видна за його межами. Також змінна if_variable, яка була оголошена в контексті умовного оператора також видна за його межами.</p>
<ol start="2">
<li>Перевизначення змінної</li>
</ol>
<p>Якщо змінна вже була оголошена і ми хочемо ще раз оголосити змінну з таким же самим ідентифікатором, javascript дозволить це зробити.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> counter = <span class="hljs-number">2</span>;</code></pre><p>Хоча може здатися, що на цю особливість var можна було б і не звертати увагу, але сама ідея оголошення змінної із вже існуючим ідентифікатором, можливо є помилкою людини, майбутнім багом, який би хотілося дізнатися на місті, а не через процес дебага.</p>
<ol start="3">
<li>Існування до моменту ініціалізації</li>
</ol>
<p>Насправді змінна, оголошена через var вже існує, але її вміст невизначений. Давайте розглянемо наступний код:</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//undefined</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;</code></pre><p>Значення зміної undefined, що означає, що її вміст не визначений.</p>
<ol start="4">
<li>Класична задача &quot;Армія функцій&quot;</li>
</ol>
<p>Наступний код створює масив функцій-стрільців shooters. За задумом, кожен стрілець повинен виводити свій номер:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeArmy</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">var</span> shooters = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-keyword">var</span> shooter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// shooters function</span>
      <span class="hljs-built_in">console</span>.log( i ); <span class="hljs-comment">// should output number of shooters</span>
    };
    shooters.push(shooter);
  }

  <span class="hljs-keyword">return</span> shooters;
}

<span class="hljs-keyword">var</span> army = makeArmy();

army[<span class="hljs-number">0</span>](); <span class="hljs-comment">// shooter outputs 10, but need 0</span>
army[<span class="hljs-number">5</span>](); <span class="hljs-comment">// shooter outputs 10...</span>
<span class="hljs-comment">// .. all shouters outputs</span></code></pre><p>Це відбувається, тому що для всіх ітерацій циклів використовується одна змінна.</p>
<h2 id="ключове-слово-let"><a class="header-link" href="#ключове-слово-let"></a>Ключове слово let</h2>
<p>В ES6 передбачений новий спосіб для оголошення змінних через ключове слово var. <strong>Зверніть увагу</strong>, що ключове слово var також доступне і може бути використане.</p>
<p>Синтаксис оголошення змінних через ключове слово let:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> ідентифікатор = значення;
<span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;</code></pre><p>У змінної оголошеної через let є чотири ключових відмінностей від var:</p>
<ol class="list">
<li>Область видимості змінної let - блок {}</li>
</ol>
<p>Якщо ми перепишимо минулий приклад, де була продемонстрована особливість оголошення змінної через var всередині циклів у умовних операторів із використанням ключового слова let, можна побачити, що let має цілком зрозумілу область видимості, а саме не видний за межами циклів і умовних операторів.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++){
}

<span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">//ReferenceError: i is not defined</span>

<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-keyword">var</span> if_variable = <span class="hljs-number">3</span>; <span class="hljs-comment">//3</span>
}

<span class="hljs-built_in">console</span>.log(if_variable); <span class="hljs-comment">//ReferenceError: if_variable is not defined</span></code></pre><p><strong>Зверніть увагу</strong>, що в цьому випадку трапляється помилка і код зупиняє своє виконання.</p>
<p>2.</p>
<p>3.</p>
<p>4.</p>
<h2 id="ключове-слово-const"><a class="header-link" href="#ключове-слово-const"></a>Ключове слово const</h2>
<p>Оголошення const задає константу, тобто змінну, яку не можна змінювати:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> LOCALE = <span class="hljs-string">'UA'</span>;
LOCALE = <span class="hljs-string">"EU"</span>; <span class="hljs-comment">//TypeError: Assignment to constant variable.</span></code></pre><p>В остальном объявление const полностью аналогично let.</p>
<blockquote>
<p>Зауважимо, що якщо в константу присвоєно об&#39;єкт, то від зміни захищена сама константа, але не властивості всередині неї:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Вася"</span>
};

user.name = <span class="hljs-string">"Петя"</span>; <span class="hljs-comment">// Можна</span>
user = <span class="hljs-number">5</span>; <span class="hljs-comment">// Буде помилка</span></code></pre><h1 id="функції-стрілки(arrow-functions)"><a class="header-link" href="#функції-стрілки(arrow-functions)"></a>Функції стрілки(Arrow functions)</h1>
<p><strong>Вирази стрілочних функцій</strong> мають більш короткий синтаксис в порівнянні з функціональними виразами і лексично прив&#39;язані до значення this (але не прив&#39;язані до власного this, arguments, super, або new.target). Стрілочні функції завжди анонімні.</p>
<p>Давайте розглянемо функцію вищого порядку, яка приймає іншу функцію і її викликає:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">innerFunc</span>)</span>{
  <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello World"</span>;
  innerFunc(message);
}

outer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>)</span>{
  <span class="hljs-built_in">console</span>.log(message);
});</code></pre><p>В якості параметра, при виклику функції outer ми передаємо анонімну функцію. Функція верхнього порядку(outer), приймає функцію і викликає її в собі.</p>
<p>Розглянемо, як можна скоротити написання анонімної функції, при її передачі у функцію зовнішнього порядку.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">innerFunc</span>)</span>{
  <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello World"</span>;
  innerFunc(message);
}

outer(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(message);
});</code></pre><p>Можна побічити, що ми позбавилися від написання ключового слова function і від дужок, які визначають параметри функції.</p>
<p>Стрілочну функцію можна присвоїти змінній. Наприклад:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> func1 = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

<span class="hljs-keyword">let</span> func2 = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

<span class="hljs-keyword">const</span> func3 = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

func1(<span class="hljs-string">'Func1'</span>); <span class="hljs-comment">//Func1</span>
func2(<span class="hljs-string">'Func2'</span>); <span class="hljs-comment">//Func2</span>
func3(<span class="hljs-string">'Func3'</span>); <span class="hljs-comment">//Func3</span></code></pre><p>Зверніть увагу, що після оператора стрілка(=&gt;) в прикладі відсутні фігурні дужки, їх можна опустити, якщо тіло стрілкової функції складається із одного виразу.</p>
<p>За замовчуванням якщо в тілі стрілкової функції немає оператора return, він ставиться автоматично. Наприклад:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a+b;
<span class="hljs-keyword">let</span> res = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">//3</span></code></pre><p>Навідміну, від минулого прикладу, ми обернули параметри, які приймає стрілочна функція в дужки. Насправді до синтаксису написання параметрів в стрілкових функціях є деякі правила, в залежності від кількості параметрів.</p>
<p>Правила написання параметрів стрілкових функцій:</p>
<ol class="list">
<li>Якщо стрілкова функція не має жодного параметра, обо має більше двох, то параметри заточуються в круглі дужки:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">let</span> func1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> func2 = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a+b;
<span class="hljs-keyword">let</span> func3 = <span class="hljs-function">(<span class="hljs-params">a,b,c</span>) =&gt;</span> a+b+c;</code></pre><ol start="2">
<li>Якщо стрілкова функція має один параметр, то круглі дужки можна опустити:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">let</span> func1 = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a++;
<span class="hljs-keyword">let</span> func2 = <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> a++;</code></pre><h1 id="параметри-за-замовчуванням"><a class="header-link" href="#параметри-за-замовчуванням"></a>Параметри за замовчуванням</h1>
<h1 id="template-literals"><a class="header-link" href="#template-literals"></a>Template Literals</h1>
<h1 id="деструктуризація"><a class="header-link" href="#деструктуризація"></a>Деструктуризація</h1>
<h1 id="класи"><a class="header-link" href="#класи"></a>Класи</h1>
<h1 id="символьний-тип"><a class="header-link" href="#символьний-тип"></a>Символьний тип</h1>
<h1 id="promises(проміси)"><a class="header-link" href="#promises(проміси)"></a>Promises(Проміси)</h1>
<h1 id="домашнє-завдання"><a class="header-link" href="#домашнє-завдання"></a>Домашнє завдання</h1>
<h2 id="варіанти"><a class="header-link" href="#варіанти"></a>Варіанти</h2>
<h1 id="контрольні-запитання"><a class="header-link" href="#контрольні-запитання"></a>Контрольні запитання</h1>
      </div>
    </div>
  </div>

  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script type="text/javascript" src="assets/js/bootstrap.min.js"></script>
</body>
</html>
