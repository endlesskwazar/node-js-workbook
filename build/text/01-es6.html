<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>ES6</title>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap-responsive.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/pilcrow.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/hljs-github.min.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/style.css"/>
  </head>
<body>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3"><ul class="nav nav-list">
    <li class="sidebar-header-1"><a href="#es6">ES6</a></li>
    <li class="sidebar-header-1"><a href="#ключові-слова-let-і-const">Ключові слова let і const</a></li>
    <li class="sidebar-header-2"><a href="#ключове-слово-let">Ключове слово let</a></li>
    <li class="sidebar-header-2"><a href="#ключове-слово-const">Ключове слово const</a></li>
    <li class="sidebar-header-1"><a href="#функції-стрілки(arrow-functions)">Функції стрілки(Arrow functions)</a></li>
    <li class="sidebar-header-1"><a href="#параметри-за-замовчуванням">Параметри за замовчуванням</a></li>
    <li class="sidebar-header-1"><a href="#template-literals">Template Literals</a></li>
    <li class="sidebar-header-1"><a href="#деструктуризація(destructuring)">Деструктуризація(Destructuring)</a></li>
    <li class="sidebar-header-2"><a href="#object-destructuring">Object Destructuring</a></li>
    <li class="sidebar-header-2"><a href="#array-destructuring">Array Destructuring</a></li>
    <li class="sidebar-header-1"><a href="#класи">Класи</a></li>
    <li class="sidebar-header-2"><a href="#getters-&amp;-setters">Getters &amp; Setters</a></li>
    <li class="sidebar-header-2"><a href="#статичні-властивості">Статичні властивості</a></li>
    <li class="sidebar-header-2"><a href="#наслідування">Наслідування</a></li>
    <li class="sidebar-header-1"><a href="#promises(проміси)">Promises(Проміси)</a></li>
    <li class="sidebar-header-1"><a href="#домашнє-завдання">Домашнє завдання</a></li>
    <li class="sidebar-header-2"><a href="#варіанти">Варіанти</a></li>
    <li class="sidebar-header-1"><a href="#контрольні-запитання">Контрольні запитання</a></li>
</ul>
      </div>
      <div class="span9 main"><h1 id="es6"><a class="header-link" href="#es6"></a>ES6</h1>
<h1 id="ключові-слова-let-і-const"><a class="header-link" href="#ключові-слова-let-і-const"></a>Ключові слова let і const</h1>
<p>В ES5 є два способи, щоб оголосити змінні:</p>
<ol class="list">
<li>Використовуючи ключове слово var<pre class="hljs"><code><span class="hljs-keyword">var</span> count = <span class="hljs-number">1</span>;</code></pre></li>
<li>Без використання ключових слів в форматі ідентифікатор = значення(при умові, що <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a> не ввімкнений)<pre class="hljs"><code>count = <span class="hljs-number">1</span>;</code></pre></li>
</ol>
<p>Якщо другий спосіб - зло, так - як змінна оголошена тиким способом має глобальну область видимості, навіть якщо знаходиться всередені функцій, то перший спосіб це єдине, що залишається для оголошення змінних.</p>
<p>Але, ключове слово var також має свої недоліки. Давайте їх розглянемо.</p>
<ol class="list">
<li>Область видимості, при оголошенні в циклах і умовних операторах</li>
</ol>
<p>Цікавою особливістю оголоішення зміних за допомогою var в циклах і умовних конструкціях є те, що ці змінні залишаються видимі після їх виконання. Наприклад розглянемо наступний код:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++){
}

<span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">//6</span>

<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-keyword">var</span> if_variable = <span class="hljs-number">3</span>;
}

<span class="hljs-built_in">console</span>.log(if_variable); <span class="hljs-comment">//3</span></code></pre><p>Змінна i, яка використовувалася для ітерації для цикла for і була оголошена в ньому ж видна за його межами. Також змінна if_variable, яка була оголошена в контексті умовного оператора також видна за його межами.</p>
<ol start="2">
<li>Перевизначення змінної</li>
</ol>
<p>Якщо змінна вже була оголошена і ми хочемо ще раз оголосити змінну з таким же самим ідентифікатором, javascript дозволить це зробити.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> counter = <span class="hljs-number">2</span>;</code></pre><p>Хоча може здатися, що на цю особливість var можна було б і не звертати увагу, але сама ідея оголошення змінної із вже існуючим ідентифікатором, можливо є помилкою людини, майбутнім багом, який би хотілося дізнатися на місті, а не через процес дебага.</p>
<ol start="3">
<li>Існування до моменту ініціалізації</li>
</ol>
<p>Насправді змінна, оголошена через var вже існує, але її вміст невизначений. Давайте розглянемо наступний код:</p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//undefined</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;</code></pre><p>Значення зміної undefined, що означає, що її вміст не визначений.</p>
<ol start="4">
<li>Класична задача &quot;Армія функцій&quot;</li>
</ol>
<p>Наступний код створює масив функцій-стрільців shooters. За задумом, кожен стрілець повинен виводити свій номер:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeArmy</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">var</span> shooters = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-keyword">var</span> shooter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// shooters function</span>
      <span class="hljs-built_in">console</span>.log( i ); <span class="hljs-comment">// should output number of shooters</span>
    };
    shooters.push(shooter);
  }

  <span class="hljs-keyword">return</span> shooters;
}

<span class="hljs-keyword">var</span> army = makeArmy();

army[<span class="hljs-number">0</span>](); <span class="hljs-comment">// shooter outputs 10, but need 0</span>
army[<span class="hljs-number">5</span>](); <span class="hljs-comment">// shooter outputs 10...</span>
<span class="hljs-comment">// .. all shouters outputs</span></code></pre><p>Це відбувається, тому що для всіх ітерацій циклів використовується одна змінна.</p>
<h2 id="ключове-слово-let"><a class="header-link" href="#ключове-слово-let"></a>Ключове слово let</h2>
<p>В ES6 передбачений новий спосіб для оголошення змінних через ключове слово var. <strong>Зверніть увагу</strong>, що ключове слово var також доступне і може бути використане.</p>
<p>Синтаксис оголошення змінних через ключове слово let:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> ідентифікатор = значення;
<span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;</code></pre><p>У змінної оголошеної через let є чотири ключових відмінностей від var:</p>
<ol class="list">
<li>Область видимості змінної let - блок {}</li>
</ol>
<p>Якщо ми перепишимо минулий приклад, де була продемонстрована особливість оголошення змінної через var всередині циклів у умовних операторів із використанням ключового слова let, можна побачити, що let має цілком зрозумілу область видимості, а саме не видний за межами циклів і умовних операторів.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++){
}

<span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">//ReferenceError: i is not defined</span>

<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-keyword">var</span> if_variable = <span class="hljs-number">3</span>; <span class="hljs-comment">//3</span>
}

<span class="hljs-built_in">console</span>.log(if_variable); <span class="hljs-comment">//ReferenceError: if_variable is not defined</span></code></pre><p><strong>Зверніть увагу</strong>, що в цьому випадку трапляється помилка і код зупиняє своє виконання.</p>
<p>2.</p>
<p>3.</p>
<p>4.</p>
<h2 id="ключове-слово-const"><a class="header-link" href="#ключове-слово-const"></a>Ключове слово const</h2>
<p>Оголошення const задає константу, тобто змінну, яку не можна змінювати:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> LOCALE = <span class="hljs-string">'UA'</span>;
LOCALE = <span class="hljs-string">"EU"</span>; <span class="hljs-comment">//TypeError: Assignment to constant variable.</span></code></pre><p>В остальном объявление const полностью аналогично let.</p>
<blockquote>
<p>Зауважимо, що якщо в константу присвоєно об&#39;єкт, то від зміни захищена сама константа, але не властивості всередині неї:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Вася"</span>
};

user.name = <span class="hljs-string">"Петя"</span>; <span class="hljs-comment">// Можна</span>
user = <span class="hljs-number">5</span>; <span class="hljs-comment">// Буде помилка</span></code></pre><h1 id="функції-стрілки(arrow-functions)"><a class="header-link" href="#функції-стрілки(arrow-functions)"></a>Функції стрілки(Arrow functions)</h1>
<p><strong>Вирази стрілочних функцій</strong> мають більш короткий синтаксис в порівнянні з функціональними виразами і лексично прив&#39;язані до значення this (але не прив&#39;язані до власного this, arguments, super, або new.target). Стрілочні функції завжди анонімні.</p>
<p>Давайте розглянемо функцію вищого порядку, яка приймає іншу функцію і її викликає:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">innerFunc</span>)</span>{
  <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello World"</span>;
  innerFunc(message);
}

outer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>)</span>{
  <span class="hljs-built_in">console</span>.log(message);
});</code></pre><p>В якості параметра, при виклику функції outer ми передаємо анонімну функцію. Функція верхнього порядку(outer), приймає функцію і викликає її в собі.</p>
<p>Розглянемо, як можна скоротити написання анонімної функції, при її передачі у функцію зовнішнього порядку.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params">innerFunc</span>)</span>{
  <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello World"</span>;
  innerFunc(message);
}

outer(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(message);
});</code></pre><p>Можна побічити, що ми позбавилися від написання ключового слова function і від дужок, які визначають параметри функції.</p>
<p>Стрілочну функцію можна присвоїти змінній. Наприклад:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> func1 = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

<span class="hljs-keyword">let</span> func2 = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

<span class="hljs-keyword">const</span> func3 = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

func1(<span class="hljs-string">'Func1'</span>); <span class="hljs-comment">//Func1</span>
func2(<span class="hljs-string">'Func2'</span>); <span class="hljs-comment">//Func2</span>
func3(<span class="hljs-string">'Func3'</span>); <span class="hljs-comment">//Func3</span></code></pre><p>Зверніть увагу, що після оператора стрілка(=&gt;) в прикладі відсутні фігурні дужки, їх можна опустити, якщо тіло стрілкової функції складається із одного виразу.</p>
<p>За замовчуванням якщо в тілі стрілкової функції немає оператора return, він ставиться автоматично. Наприклад:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a+b;
<span class="hljs-keyword">let</span> res = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">//3</span></code></pre><p>Навідміну, від минулого прикладу, ми обернули параметри, які приймає стрілочна функція в дужки. Насправді до синтаксису написання параметрів в стрілкових функціях є деякі правила, в залежності від кількості параметрів.</p>
<p>Правила написання параметрів стрілкових функцій:</p>
<ol class="list">
<li>Якщо стрілкова функція не має жодного параметра, обо має більше двох, то параметри заточуються в круглі дужки:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">let</span> func1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> func2 = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a+b;
<span class="hljs-keyword">let</span> func3 = <span class="hljs-function">(<span class="hljs-params">a,b,c</span>) =&gt;</span> a+b+c;</code></pre><ol start="2">
<li>Якщо стрілкова функція має один параметр, то круглі дужки можна опустити:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">let</span> func1 = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a++;
<span class="hljs-keyword">let</span> func2 = <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> a++;</code></pre><h1 id="параметри-за-замовчуванням"><a class="header-link" href="#параметри-за-замовчуванням"></a>Параметри за замовчуванням</h1>
<p><strong>Параметри за замовчуванням</strong> дозволяють задавати формальним параметрам функції значення за замовчуванням, якщо для них не вказано значення або переданий undefined.</p>
<p>ES5 немає такої фічі як параметри за замовчуванням. Щоб імітувати, використовувався паттерн &quot;параметри за замовчуванням&quot;. Працює він наступним чином:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
  a = a || <span class="hljs-number">10</span>;
  b = b || <span class="hljs-number">20</span>;
  <span class="hljs-keyword">return</span> a + b;
};
sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span>
sum(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 21</span>
sum();     <span class="hljs-comment">// 30</span></code></pre><p>Функція sum приймає два параметра a і b і повертає їх суму. Якщо параметр b не був переданий, то він автоматично стає рівним 20, якщо ж не було передано жодного параметра - a присвоюється значення 10, а b - 20. Все працює добре до тих пір, поки не з&#39;являється необхідність передати помилкове значення, наприклад, нуль:</p>
<pre class="hljs"><code><span class="hljs-comment">// Вираз (0 || 10) поверне 10, так як 0 - хибне значення</span>
sum(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 11</span></code></pre><p>Для того, щоб уникнути подібних проблем, можна використати тернарний оператор:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
  a = (a !== <span class="hljs-literal">undefined</span>) ? a : <span class="hljs-number">10</span>;
  b = (b !== <span class="hljs-literal">undefined</span>) ? b : <span class="hljs-number">20</span>;
  <span class="hljs-keyword">return</span> a + b;
};</code></pre><p>З релізом ES6 з&#39;явилася можливість задавати параметри за замовчуванням при оголошенні функції:</p>
<p>Синтаксис:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> [<span class="hljs-title">name</span>](<span class="hljs-params">[param1[ = defaultValue1 ][, ..., paramN[ = defaultValueN ]]]</span>) </span>{
   statements
}</code></pre><p>Приклад:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span></span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
};</code></pre><h1 id="template-literals"><a class="header-link" href="#template-literals"></a>Template Literals</h1>
<p><strong>Шаблонними літералами</strong> називаються рядкові літерали, що дозволяють застосування виразів всередині. З ними ви можете використовувати багаторядкові літерали і строкову інтерполяцію. У специфікаціях до ES2015 вони називалися &quot;шаблонними рядками&quot;.</p>
<p>Синтаксис:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">`some text`</span>;
<span class="hljs-keyword">let</span> str2 = <span class="hljs-string">`
some text
`</span>;

<span class="hljs-built_in">console</span>.log(str1); <span class="hljs-comment">//some text</span>
<span class="hljs-built_in">console</span>.log(str2); <span class="hljs-comment">//some text</span></code></pre><p>Для використання виразів всередині, використовується наступний синтаксис:</p>
<pre class="hljs"><code><span class="hljs-string">`<span class="hljs-subst">${expression}</span>`</span></code></pre><p>Наприклад:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> terminator = <span class="hljs-number">0</span>;

<span class="hljs-keyword">let</span> str = <span class="hljs-string">`
Terminator is <span class="hljs-subst">${terminator}</span>. Counter variable is 
<span class="hljs-subst">${counter}</span>
`</span>;

<span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">//Terminator is 0. Counter variable is 1</span></code></pre><h1 id="деструктуризація(destructuring)"><a class="header-link" href="#деструктуризація(destructuring)"></a>Деструктуризація(Destructuring)</h1>
<p><strong>Деструктуризація</strong> просто розбиття складної структури на більш прості частини. У JavaScript ця складна структура зазвичай є об&#39;єктом або масивом. За допомогою синтаксису деструкції ви можете витягувати менші фрагменти з масивів і об&#39;єктів.</p>
<h2 id="object-destructuring"><a class="header-link" href="#object-destructuring"></a>Object Destructuring</h2>
<p>Рззглянемо намтупний об&#39;єкт:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> car = {
  <span class="hljs-attr">model</span>: <span class="hljs-string">'A8'</span>,
  <span class="hljs-attr">brand</span>: <span class="hljs-string">'Audi'</span>,
  <span class="hljs-attr">engine</span>: <span class="hljs-string">'V8'</span>
};</code></pre><p>Щоь деструктуризувати цей об&#39;єкт потрібно в лівій частині присвоєння, перечислити назви властивостей які ми хочемо мати, а в правій сам об&#39;єкт деструктуризації:</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> car = {
  <span class="hljs-attr">model</span>: <span class="hljs-string">'A8'</span>,
  <span class="hljs-attr">brand</span>: <span class="hljs-string">'Audi'</span>,
  <span class="hljs-attr">engine</span>: <span class="hljs-string">'V8'</span>
};

<span class="hljs-keyword">const</span> {model, brand} = car;
<span class="hljs-built_in">console</span>.log(model, brand); <span class="hljs-comment">//A8 Audi</span></code></pre><h2 id="array-destructuring"><a class="header-link" href="#array-destructuring"></a>Array Destructuring</h2>
<h1 id="класи"><a class="header-link" href="#класи"></a>Класи</h1>
<p><strong>Класи</strong> в JavaScript були введені в ECMAScript 2015 і являють собою синтаксичний цукор над існуючим в JavaScript механізмом прототипного наслідування. Синтаксис класів не вводить нову об&#39;єктно-орієнтовану модель, а надає більш простий і зрозумілий спосіб створення об&#39;єктів і організації наслідування.</p>
<p>Синтаксис:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> Назва [<span class="hljs-keyword">extends</span> Батьківський клас]  </span>{
  <span class="hljs-keyword">constructor</span>
  методи
}</code></pre><p>Як видноі із синтаксису оголошення класу в JS, в класі можна описати конструктор і методи, оголошення властивостей не передбачено. Але властивості можна оголосити всередині конструктора або будь-якого метода(За допомогою ключового слова this). Головне, щоб цей метод відпрацював до звернення до властивості.</p>
<p>Також не має можливості вказувати модифікатори доступу, такі як private, public, protected.</p>
<p><strong>Приклад №1:</strong> Оголошення класа із конструктором, створення екземпляра класу.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kernel</span> </span>{
  <span class="hljs-keyword">constructor</span>(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Starting init the kernel'</span>);
  }
}

<span class="hljs-keyword">let</span> kernel = <span class="hljs-keyword">new</span> Kernel(); <span class="hljs-comment">//starting init the kernel</span></code></pre><p><strong>Приклад №2:</strong> Оголошення класа із конструктором і методом, створення екземпляра класу і виклик методу.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kernel</span> </span>{
  <span class="hljs-keyword">constructor</span>(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Starting init the kernel'</span>);
  }

  boot(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'boot up'</span>)
  }
}

<span class="hljs-keyword">let</span> kernel = <span class="hljs-keyword">new</span> Kernel(); <span class="hljs-comment">//starting init the kernel</span>
kernel.boot(); <span class="hljs-comment">//boot up</span></code></pre><p><strong>Приклад №3:</strong> Оголошення класа із конструктором і методм, передача парамтра в конструктор і створення властивості, створення екземпляра класу, виклик методу і виведення значення властивості.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kernel</span> </span>{
  <span class="hljs-keyword">constructor</span>(mode){
    <span class="hljs-keyword">this</span>.mode = mode;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Starting init the kernel in mode <span class="hljs-subst">${<span class="hljs-keyword">this</span>.mode}</span>`</span>);
  }

  boot(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'boot up'</span>)
  }
}

<span class="hljs-keyword">let</span> kernel = <span class="hljs-keyword">new</span> Kernel(<span class="hljs-string">'silent'</span>); <span class="hljs-comment">//starting init the kernel in mode silent</span>
kernel.boot(); <span class="hljs-comment">//boot up</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`mode is <span class="hljs-subst">${kernel.mode}</span>`</span>);</code></pre><p><strong>Приклад №3:</strong> Створення властивостей в методі.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kernel</span> </span>{
  <span class="hljs-keyword">constructor</span>(mode){
    <span class="hljs-keyword">this</span>.mode = mode;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Starting init the kernel in mode <span class="hljs-subst">${<span class="hljs-keyword">this</span>.mode}</span>`</span>);
  }

  boot(){
    <span class="hljs-keyword">this</span>.bootStatus = <span class="hljs-string">'ok'</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'boot up'</span>)
  }
}

<span class="hljs-keyword">let</span> kernel = <span class="hljs-keyword">new</span> Kernel(<span class="hljs-string">'silent'</span>); <span class="hljs-comment">//starting init the kernel in mode silent</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`boot status is <span class="hljs-subst">${kernel.bootStatus}</span>`</span>);<span class="hljs-comment">//undefined</span>
kernel.boot(); <span class="hljs-comment">//boot up</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`mode is <span class="hljs-subst">${kernel.mode}</span>`</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`boot status is <span class="hljs-subst">${kernel.bootStatus}</span>`</span>); <span class="hljs-comment">//boot status is ok</span></code></pre><h2 id="getters-&-setters"><a class="header-link" href="#getters-&-setters"></a>Getters &amp; Setters</h2>
<p>У класах, як і в звичайних об&#39;єктах, можна оголошувати геттери і сеттери через get / set, а також використовувати [...] для властивостей з обчислювальними іменами.</p>
<p><strong>Приклад №3:</strong> Створення геттера і сеттера.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
  <span class="hljs-keyword">constructor</span>(firstName, lastName){
    <span class="hljs-keyword">this</span>.firstName = firstName;
    <span class="hljs-keyword">this</span>.lastName = lastName;
  }

  get fullName(){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName;
  }

  set fullName(val) {
    [<span class="hljs-keyword">this</span>.firstName, <span class="hljs-keyword">this</span>.lastName] = val.split(<span class="hljs-string">' '</span>);
  }
}

<span class="hljs-keyword">let</span> empl = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">'Вася'</span>, <span class="hljs-string">'Пупкін'</span>);
<span class="hljs-built_in">console</span>.log(empl.fullName); <span class="hljs-comment">//Вася Пупкін</span>
empl.fullName = <span class="hljs-string">'Іван Іванов'</span>;
<span class="hljs-built_in">console</span>.log(empl.fullName); <span class="hljs-comment">//Іван Іванов</span></code></pre><p>Зверніть увагу, що після ініціалізації об&#39;єкта до методів, які оголошені із використанням геттерів і сеттерів використовується синтаксис властивостей, а не виклику методів.</p>
<p><strong>Приклад №3:</strong> Динамічно обчислювані імена методів.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span> </span>{
  <span class="hljs-keyword">constructor</span>(method){
    <span class="hljs-keyword">this</span>.method = method;
  }

  [<span class="hljs-string">"hi"</span>.toUpperCase()]() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'it works'</span>);
  }
}

<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> Obj(<span class="hljs-string">'hi'</span>);
obj.HI();</code></pre><h2 id="статичні-властивості"><a class="header-link" href="#статичні-властивості"></a>Статичні властивості</h2>
<h2 id="наслідування"><a class="header-link" href="#наслідування"></a>Наслідування</h2>
<h1 id="promises(проміси)"><a class="header-link" href="#promises(проміси)"></a>Promises(Проміси)</h1>
<h1 id="домашнє-завдання"><a class="header-link" href="#домашнє-завдання"></a>Домашнє завдання</h1>
<p>Відкрийте <a href="https://repl.it/languages/nodejs">repl.it</a>.</p>
<h2 id="варіанти"><a class="header-link" href="#варіанти"></a>Варіанти</h2>
<h1 id="контрольні-запитання"><a class="header-link" href="#контрольні-запитання"></a>Контрольні запитання</h1>
<ol class="list">
<li>Поясніть модель версіонування JavaScript.</li>
<li>Яка різниця між var і let?</li>
<li>Що таке Arrow Function? Яка перевага Arrow Function над традиційною функцією JavaScript?</li>
<li>Поясніть шаблонні літерали.</li>
<li>Поясніть деструктуризацію об&#39;єктів і масивів в JavaScript?</li>
<li>Поясніть принцип створення класів за допомогою ключового слова class.</li>
<li>Що таке проміси(Promises)?</li>
</ol>
      </div>
    </div>
  </div>

  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script type="text/javascript" src="assets/js/bootstrap.min.js"></script>
</body>
</html>
